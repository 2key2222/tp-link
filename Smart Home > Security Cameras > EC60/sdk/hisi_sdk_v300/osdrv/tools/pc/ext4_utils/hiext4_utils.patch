diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..0835829
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,41 @@
+#
+#  Create By Czyong
+#
+#  make_ext4fs -l 128M -s rootfs.ext4 ./rootfs
+#
+################################################################################
+
+CC      := gcc
+CFLAGS  := -I.
+LDFLAGS := -lz
+TARGETS := make_ext4fs
+DEPS    := $(COBJS:.o=.d)
+
+
+make_ext4fs_OBJS := make_ext4fs_main.o ext4fixup.o ext4_utils.o output_file.o \
+	allocate.o sparse_crc32.o make_ext4fs.o contents.o \
+	extent.o indirect.o backed_block.o uuid.o wipe.o \
+	sha1.o
+
+COBJS            := $(make_ext4fs_OBJS)
+################################################################################
+
+all: $(TARGETS)
+
+make_ext4fs: $(make_ext4fs_OBJS)
+	$(CC) $(make_ext4fs_OBJS) -o $@ $(CFLAGS) $(LDFLAGS)
+
+%.o: %.c
+	$(CC) $(CFLAGS) -c $< -o $@
+
+%.d : %.c
+	@set -e; $(CC) $(CFLAGS) -MM $< | sed 's,$*.o:,$*.o $*.d:,g' > $@
+
+clean:
+	@rm -f $(COBJS)
+	@rm -f $(TARGETS)
+	@rm -f $(DEPS)
+
+ifneq ("$(MAKECMDGOALS)","clean")
+sinclude $(DEPS)
+endif
diff --git a/android_filesystem_config.h b/android_filesystem_config.h
new file mode 100644
index 0000000..5fc95ea
--- /dev/null
+++ b/android_filesystem_config.h
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* This file is used to define the properties of the filesystem
+** images generated by build tools (mkbootfs and mkyaffs2image) and
+** by the device side of adb.
+*/
+
+#ifndef _ANDROID_FILESYSTEM_CONFIG_H_
+#define _ANDROID_FILESYSTEM_CONFIG_H_
+
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/* This is the master Users and Groups config for the platform.
+** DO NOT EVER RENUMBER.
+*/
+
+#define AID_ROOT             0  /* traditional unix root user */
+
+#define AID_SYSTEM        1000  /* system server */
+
+#define AID_RADIO         1001  /* telephony subsystem, RIL */
+#define AID_BLUETOOTH     1002  /* bluetooth subsystem */
+#define AID_GRAPHICS      1003  /* graphics devices */
+#define AID_INPUT         1004  /* input devices */
+#define AID_AUDIO         1005  /* audio devices */
+#define AID_CAMERA        1006  /* camera devices */
+#define AID_LOG           1007  /* log devices */
+#define AID_COMPASS       1008  /* compass device */
+#define AID_MOUNT         1009  /* mountd socket */
+#define AID_WIFI          1010  /* wifi subsystem */
+#define AID_ADB           1011  /* android debug bridge (adbd) */
+#define AID_INSTALL       1012  /* group for installing packages */
+#define AID_MEDIA         1013  /* mediaserver process */
+#define AID_DHCP          1014  /* dhcp client */
+#define AID_SDCARD_RW     1015  /* external storage write access */
+#define AID_VPN           1016  /* vpn system */
+#define AID_KEYSTORE      1017  /* keystore subsystem */
+#define AID_USB           1018  /* USB devices */
+#define AID_DRM           1019  /* DRM server */
+#define AID_MDNSR         1020  /* MulticastDNSResponder (service discovery) */
+#define AID_GPS           1021  /* GPS daemon */
+#define AID_UNUSED1       1022  /* deprecated, DO NOT USE */
+#define AID_MEDIA_RW      1023  /* internal media storage write access */
+#define AID_MTP           1024  /* MTP USB driver access */
+#define AID_UNUSED2       1025  /* deprecated, DO NOT USE */
+#define AID_DRMRPC        1026  /* group for drm rpc */
+#define AID_NFC           1027  /* nfc subsystem */
+#define AID_SDCARD_R      1028  /* external storage read access */
+
+#define AID_SHELL         2000  /* adb and debug shell user */
+#define AID_CACHE         2001  /* cache access */
+#define AID_DIAG          2002  /* access to diagnostic resources */
+
+/* The 3000 series are intended for use as supplemental group id's only.
+ * They indicate special Android capabilities that the kernel is aware of. */
+#define AID_NET_BT_ADMIN  3001  /* bluetooth: create any socket */
+#define AID_NET_BT        3002  /* bluetooth: create sco, rfcomm or l2cap sockets */
+#define AID_INET          3003  /* can create AF_INET and AF_INET6 sockets */
+#define AID_NET_RAW       3004  /* can create raw INET sockets */
+#define AID_NET_ADMIN     3005  /* can configure interfaces and routing tables. */
+#define AID_NET_BW_STATS  3006  /* read bandwidth statistics */
+#define AID_NET_BW_ACCT   3007  /* change bandwidth statistics accounting */
+
+#define AID_MISC          9998  /* access to misc storage */
+#define AID_NOBODY        9999
+
+#define AID_APP          10000  /* first app user */
+
+#define AID_ISOLATED_START 99000 /* start of uids for fully isolated sandboxed processes */
+#define AID_ISOLATED_END   99999 /* end of uids for fully isolated sandboxed processes */
+
+#define AID_USER        100000  /* offset for uid ranges for each user */
+
+#if !defined(EXCLUDE_FS_CONFIG_STRUCTURES)
+struct android_id_info {
+    const char *name;
+    unsigned aid;
+};
+
+static const struct android_id_info android_ids[] = {
+    { "root",      AID_ROOT, },
+    { "system",    AID_SYSTEM, },
+    { "radio",     AID_RADIO, },
+    { "bluetooth", AID_BLUETOOTH, },
+    { "graphics",  AID_GRAPHICS, },
+    { "input",     AID_INPUT, },
+    { "audio",     AID_AUDIO, },
+    { "camera",    AID_CAMERA, },
+    { "log",       AID_LOG, },
+    { "compass",   AID_COMPASS, },
+    { "mount",     AID_MOUNT, },
+    { "wifi",      AID_WIFI, },
+    { "dhcp",      AID_DHCP, },
+    { "adb",       AID_ADB, },
+    { "install",   AID_INSTALL, },
+    { "media",     AID_MEDIA, },
+    { "drm",       AID_DRM, },
+    { "mdnsr",     AID_MDNSR, },
+    { "nfc",       AID_NFC, },
+    { "drmrpc",    AID_DRMRPC, },
+    { "shell",     AID_SHELL, },
+    { "cache",     AID_CACHE, },
+    { "diag",      AID_DIAG, },
+    { "net_bt_admin", AID_NET_BT_ADMIN, },
+    { "net_bt",    AID_NET_BT, },
+    { "sdcard_r",  AID_SDCARD_R, },
+    { "sdcard_rw", AID_SDCARD_RW, },
+    { "media_rw",  AID_MEDIA_RW, },
+    { "vpn",       AID_VPN, },
+    { "keystore",  AID_KEYSTORE, },
+    { "usb",       AID_USB, },
+    { "mtp",       AID_MTP, },
+    { "gps",       AID_GPS, },
+    { "inet",      AID_INET, },
+    { "net_raw",   AID_NET_RAW, },
+    { "net_admin", AID_NET_ADMIN, },
+    { "net_bw_stats", AID_NET_BW_STATS, },
+    { "net_bw_acct", AID_NET_BW_ACCT, },
+    { "misc",      AID_MISC, },
+    { "nobody",    AID_NOBODY, },
+};
+
+#define android_id_count \
+    (sizeof(android_ids) / sizeof(android_ids[0]))
+
+struct fs_path_config {
+    unsigned mode;
+    unsigned uid;
+    unsigned gid;
+    const char *prefix;
+};
+
+/* Rules for directories.
+** These rules are applied based on "first match", so they
+** should start with the most specific path and work their
+** way up to the root.
+*/
+
+static struct fs_path_config android_dirs[] = {
+    { 00770, AID_SYSTEM, AID_CACHE,  "cache" },
+    { 00771, AID_SYSTEM, AID_SYSTEM, "data/app" },
+    { 00771, AID_SYSTEM, AID_SYSTEM, "data/app-private" },
+    { 00771, AID_SYSTEM, AID_SYSTEM, "data/dalvik-cache" },
+    { 00771, AID_SYSTEM, AID_SYSTEM, "data/data" },
+    { 00771, AID_SHELL,  AID_SHELL,  "data/local/tmp" },
+    { 00771, AID_SHELL,  AID_SHELL,  "data/local" },
+    { 01771, AID_SYSTEM, AID_MISC,   "data/misc" },
+    { 00770, AID_DHCP,   AID_DHCP,   "data/misc/dhcp" },
+    { 00775, AID_MEDIA_RW, AID_MEDIA_RW, "data/media" },
+    { 00775, AID_MEDIA_RW, AID_MEDIA_RW, "data/media/Music" },
+    { 00771, AID_SYSTEM, AID_SYSTEM, "data" },
+    { 00750, AID_ROOT,   AID_SHELL,  "sbin" },
+    { 00755, AID_ROOT,   AID_SHELL,  "system/bin" },
+    { 00755, AID_ROOT,   AID_SHELL,  "system/vendor" },
+    { 00755, AID_ROOT,   AID_SHELL,  "system/xbin" },
+    { 00755, AID_ROOT,   AID_ROOT,   "system/etc/ppp" },
+    { 00777, AID_ROOT,   AID_ROOT,   "sdcard" },
+    { 00755, AID_ROOT,   AID_ROOT,   0 },
+};
+
+/* Rules for files.
+** These rules are applied based on "first match", so they
+** should start with the most specific path and work their
+** way up to the root. Prefixes ending in * denotes wildcard
+** and will allow partial matches.
+*/
+static struct fs_path_config android_files[] = {
+    { 00440, AID_ROOT,      AID_SHELL,     "system/etc/init.goldfish.rc" },
+    { 00550, AID_ROOT,      AID_SHELL,     "system/etc/init.goldfish.sh" },
+    { 00440, AID_ROOT,      AID_SHELL,     "system/etc/init.trout.rc" },
+    { 00550, AID_ROOT,      AID_SHELL,     "system/etc/init.ril" },
+    { 00550, AID_ROOT,      AID_SHELL,     "system/etc/init.testmenu" },
+    { 00550, AID_DHCP,      AID_SHELL,     "system/etc/dhcpcd/dhcpcd-run-hooks" },
+    { 00440, AID_BLUETOOTH, AID_BLUETOOTH, "system/etc/dbus.conf" },
+    { 00440, AID_BLUETOOTH, AID_BLUETOOTH, "system/etc/bluetooth/main.conf" },
+    { 00440, AID_BLUETOOTH, AID_BLUETOOTH, "system/etc/bluetooth/input.conf" },
+    { 00440, AID_BLUETOOTH, AID_BLUETOOTH, "system/etc/bluetooth/audio.conf" },
+    { 00440, AID_BLUETOOTH, AID_BLUETOOTH, "system/etc/bluetooth/network.conf" },
+    { 00444, AID_NET_BT,    AID_NET_BT,    "system/etc/bluetooth/blacklist.conf" },
+    { 00640, AID_SYSTEM,    AID_SYSTEM,    "system/etc/bluetooth/auto_pairing.conf" },
+    { 00444, AID_RADIO,     AID_AUDIO,     "system/etc/AudioPara4.csv" },
+    { 00555, AID_ROOT,      AID_ROOT,      "system/etc/ppp/*" },
+    { 00555, AID_ROOT,      AID_ROOT,      "system/etc/rc.*" },
+    { 00644, AID_SYSTEM,    AID_SYSTEM,    "data/app/*" },
+    { 00644, AID_MEDIA_RW,  AID_MEDIA_RW,  "data/media/*" },
+    { 00644, AID_SYSTEM,    AID_SYSTEM,    "data/app-private/*" },
+    { 00644, AID_APP,       AID_APP,       "data/data/*" },
+        /* the following two files are INTENTIONALLY set-gid and not set-uid.
+         * Do not change. */
+    { 02755, AID_ROOT,      AID_NET_RAW,   "system/bin/ping" },
+    { 02750, AID_ROOT,      AID_INET,      "system/bin/netcfg" },
+    	/* the following five files are INTENTIONALLY set-uid, but they
+	 * are NOT included on user builds. */
+    { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/su" },
+    { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/librank" },
+    { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/procrank" },
+    { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/procmem" },
+    { 06755, AID_ROOT,      AID_ROOT,      "system/xbin/tcpdump" },
+    { 04770, AID_ROOT,      AID_RADIO,     "system/bin/pppd-ril" },
+		/* the following file is INTENTIONALLY set-uid, and IS included
+		 * in user builds. */
+    { 06750, AID_ROOT,      AID_SHELL,     "system/bin/run-as" },
+    { 00755, AID_ROOT,      AID_SHELL,     "system/bin/*" },
+    { 00755, AID_ROOT,      AID_ROOT,      "system/lib/valgrind/*" },
+    { 00755, AID_ROOT,      AID_SHELL,     "system/xbin/*" },
+    { 00755, AID_ROOT,      AID_SHELL,     "system/vendor/bin/*" },
+    { 00750, AID_ROOT,      AID_SHELL,     "sbin/*" },
+    { 00755, AID_ROOT,      AID_ROOT,      "bin/*" },
+    { 00750, AID_ROOT,      AID_SHELL,     "init*" },
+    { 00750, AID_ROOT,      AID_SHELL,     "charger*" },
+    { 00750, AID_ROOT,      AID_SHELL,     "sbin/fs_mgr" },
+    { 00640, AID_ROOT,      AID_SHELL,     "fstab.*" },
+    { 00644, AID_ROOT,      AID_ROOT,       0 },
+};
+
+static inline void fs_config(const char *path, int dir,
+                             unsigned *uid, unsigned *gid, unsigned *mode)
+{
+#if 0
+    struct fs_path_config *pc;
+    int plen;
+
+    pc = dir ? android_dirs : android_files;
+    plen = strlen(path);
+    for(; pc->prefix; pc++){
+        int len = strlen(pc->prefix);
+        if (dir) {
+            if(plen < len) continue;
+            if(!strncmp(pc->prefix, path, len)) break;
+            continue;
+        }
+        /* If name ends in * then allow partial matches. */
+        if (pc->prefix[len -1] == '*') {
+            if(!strncmp(pc->prefix, path, len - 1)) break;
+        } else if (plen == len){
+            if(!strncmp(pc->prefix, path, len)) break;
+        }
+    }
+    *uid = pc->uid;
+    *gid = pc->gid;
+    *mode = (*mode & (~07777)) | pc->mode;
+#else
+	*uid = 00755;
+	*gid = AID_ROOT;
+	*mode = (*mode & (~07777)) | AID_ROOT;
+
+#endif
+}
+#endif
+#endif
diff --git a/contents.c b/contents.c
index de38bb0..de9de9c 100644
--- a/contents.c
+++ b/contents.c
@@ -27,10 +27,6 @@
 #include "indirect.h"
 #include "xattr.h"
 
-#ifdef USE_MINGW
-#define S_IFLNK 0  /* used by make_link, not needed under mingw */
-#endif
-
 static u32 dentry_size(u32 entries, struct dentry *dentries)
 {
 	u32 len = 24;
@@ -233,6 +229,33 @@ u32 make_link(const char *filename, const char *link)
 	return inode_num;
 }
 
+u32 make_chrdev(const char *filename, u64 len)
+{
+	struct ext4_inode *inode;
+	u32 inode_num;
+	
+	inode_num = allocate_inode(info);
+	if (inode_num == EXT4_ALLOCATE_FAILED) {
+		error("failed to allocate inode\n");
+		return EXT4_ALLOCATE_FAILED;
+	}
+
+	inode = get_inode(inode_num);
+	if (inode == NULL) {
+		error("failed to get inode %u", inode_num);
+		return EXT4_ALLOCATE_FAILED;
+	}
+
+	inode->i_mode = S_IFCHR;
+	inode->i_links_count = 1;
+	inode->i_size_lo = len;
+	inode->i_flags |= aux_info.default_i_flags;
+
+	inode_allocate_extents(inode, len);
+
+	return inode_num;
+}
+
 int inode_set_permissions(u32 inode_num, u16 mode, u16 uid, u16 gid, u32 mtime)
 {
 	struct ext4_inode *inode = get_inode(inode_num);
@@ -250,50 +273,7 @@ int inode_set_permissions(u32 inode_num, u16 mode, u16 uid, u16 gid, u32 mtime)
 	return 0;
 }
 
-#ifdef HAVE_SELINUX
-#define XATTR_SELINUX_SUFFIX "selinux"
-
-/* XXX */
-#define cpu_to_le32(x) (x)
-#define cpu_to_le16(x) (x)
-
-int inode_set_selinux(u32 inode_num, const char *secon)
-{
-	struct ext4_inode *inode = get_inode(inode_num);
-	u32 *hdr;
-	struct ext4_xattr_entry *entry;
-	size_t name_len = strlen(XATTR_SELINUX_SUFFIX);
-	size_t value_len = strlen(secon)+1;
-	size_t size, min_offs;
-	char *val;
-
-	if (!secon)
-		return 0;
-
-	if (!inode)
-		return -1;
-
-	hdr = (u32 *) (inode + 1);
-	*hdr = cpu_to_le32(EXT4_XATTR_MAGIC);
-	entry = (struct ext4_xattr_entry *) (hdr+1);
-	memset(entry, 0, EXT4_XATTR_LEN(name_len));
-	entry->e_name_index = EXT4_XATTR_INDEX_SECURITY;
-	entry->e_name_len = name_len;
-	memcpy(entry->e_name, XATTR_SELINUX_SUFFIX, name_len);
-	entry->e_value_size = cpu_to_le32(value_len);
-	min_offs = (char *)inode + info.inode_size - (char*) entry;
-	size = EXT4_XATTR_SIZE(value_len);
-	val = (char *)entry + min_offs - size;
-	entry->e_value_offs = cpu_to_le16(min_offs - size);
-	memset(val + size - EXT4_XATTR_PAD, 0, EXT4_XATTR_PAD);
-	memcpy(val, secon, value_len);
-	inode->i_extra_isize = cpu_to_le16(sizeof(struct ext4_inode) - EXT4_GOOD_OLD_INODE_SIZE);
-
-	return 0;
-}
-#else
 int inode_set_selinux(u32 inode_num, const char *secon)
 {
 	return 0;
 }
-#endif
diff --git a/ext4_utils.c b/ext4_utils.c
index 7f226c8..eb7b8d2 100644
--- a/ext4_utils.c
+++ b/ext4_utils.c
@@ -27,12 +27,8 @@
 #include <sys/types.h>
 #include <string.h>
 
-#ifdef USE_MINGW
-#include <winsock2.h>
-#else
 #include <arpa/inet.h>
 #include <sys/ioctl.h>
-#endif
 
 #if defined(__linux__)
 #include <linux/fs.h>
diff --git a/ext4fixup.c b/ext4fixup.c
index c664ac3..ea0700f 100644
--- a/ext4fixup.c
+++ b/ext4fixup.c
@@ -27,9 +27,7 @@
 #include <fcntl.h>
 #include <unistd.h>
 
-#ifndef USE_MINGW
 #include <sys/mman.h>
-#endif
 
 #if defined(__APPLE__) && defined(__MACH__)
 #define lseek64 lseek
diff --git a/img2simg.c b/img2simg.c
deleted file mode 100644
index 3b46613..0000000
--- a/img2simg.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Copyright (C) 2010-2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define DEFAULT_BLOCK_SIZE	"4K"
-#define DEFAULT_CHUNK_SIZE	"64M"
-#define DEFAULT_SUFFIX		"%03d"
-
-#include "ext4_utils.h"
-#include "sparse_format.h"
-#if 0 /* endian.h is not on all platforms */
-# include <endian.h>
-#else
-  /* For now, just assume we're going to run on little-endian. */
-# define my_htole32(h) (h)
-# define my_htole16(h) (h)
-#endif
-#include <errno.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <stdarg.h>
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#define COPY_BUF_SIZE (1024*1024)
-static char *copy_buf;
-
-static const char *progname(const char *argv0)
-{
-    const char *prog_name;
-    if ((prog_name = strrchr(argv0, '/')))
-	return(prog_name + 1);	/* Advance beyond '/'. */
-    return(argv0);		/* No '/' in argv0, use it as is. */
-}
-
-static void error_exit(const char *fmt, ...)
-{
-    va_list ap;
-    va_start(ap, fmt);
-    vfprintf(stderr, fmt, ap);
-    fputc('\n', stderr);
-    va_end(ap);
-
-    exit(EXIT_FAILURE);
-}
-
-static void usage(const char *argv0, const char *error_fmt, ...)
-{
-    fprintf(stderr,
-	    "Usage: %s [OPTIONS] <raw_image_file>\n",
-	    progname(argv0));
-    fprintf(stderr, "The <raw_image_file> will be split into as many sparse\n");
-    fprintf(stderr, "files as needed.  Each sparse file will contain a single\n");
-    fprintf(stderr, "DONT CARE chunk to offset to the correct block and then\n");
-    fprintf(stderr, "a single RAW chunk containing a portion of the data from\n");
-    fprintf(stderr, "the raw image file.  The sparse files will be named by\n");
-    fprintf(stderr, "appending a number to the name of the raw image file.\n");
-    fprintf(stderr, "\n");
-    fprintf(stderr, "OPTIONS (Defaults are enclosed by square brackets):\n");
-    fprintf(stderr, "  -s SUFFIX      Format appended number with SUFFIX [%s]\n",
-	    DEFAULT_SUFFIX);
-    fprintf(stderr, "  -B SIZE        Use a block size of SIZE [%s]\n",
-	    DEFAULT_BLOCK_SIZE);
-    fprintf(stderr, "  -C SIZE        Use a chunk size of SIZE [%s]\n",
-	    DEFAULT_CHUNK_SIZE);
-    fprintf(stderr, "SIZE is a decimal integer that may optionally be\n");
-    fprintf(stderr, "followed by a suffix that specifies a multiplier for\n");
-    fprintf(stderr, "the integer:\n");
-    fprintf(stderr, "       c         1 byte (the default when omitted)\n");
-    fprintf(stderr, "       w         2 bytes\n");
-    fprintf(stderr, "       b         512 bytes\n");
-    fprintf(stderr, "       kB        1000 bytes\n");
-    fprintf(stderr, "       K         1024 bytes\n");
-    fprintf(stderr, "       MB        1000*1000 bytes\n");
-    fprintf(stderr, "       M         1024*1024 bytes\n");
-    fprintf(stderr, "       GB        1000*1000*1000 bytes\n");
-    fprintf(stderr, "       G         1024*1024*1024 bytes\n");
-
-    if (error_fmt && *error_fmt)
-    {
-	fprintf(stderr, "\n");
-	va_list ap;
-	va_start(ap, error_fmt);
-	vfprintf(stderr, error_fmt, ap);
-	va_end(ap);
-	fprintf(stderr, "\n");
-    }
-
-    exit(EXIT_FAILURE);
-}
-
-static void cpy_file(int out_fd, char *out_path, int in_fd, char *in_path,
-		     size_t len)
-{
-    ssize_t s, cpy_len = COPY_BUF_SIZE;
-
-    while (len) {
-	if (len < COPY_BUF_SIZE)
-	    cpy_len = len;
-
-	s = read(in_fd, copy_buf, cpy_len);
-	if (s < 0)
-	    error_exit("\"%s\": %s", in_path, strerror(errno));
-	if (!s)
-	    error_exit("\"%s\": Unexpected EOF", in_path);
-
-	cpy_len = s;
-
-	s = write(out_fd, copy_buf, cpy_len);
-	if (s < 0)
-	    error_exit("\"%s\": %s", out_path, strerror(errno));
-	if (s != cpy_len)
-	    error_exit("\"%s\": Short data write (%lu)", out_path,
-		       (unsigned long)s);
-
-	len -= cpy_len;
-    }
-}
-
-static int parse_size(const char *size_str, size_t *size)
-{
-    static const size_t MAX_SIZE_T = ~(size_t)0;
-    size_t mult;
-    unsigned long long int value;
-    const char *end;
-    errno = 0;
-    value = strtoull(size_str, (char **)&end, 10);
-    if (errno != 0 || end == size_str || value > MAX_SIZE_T)
-	return -1;
-    if (*end == '\0') {
-	*size = value;
-	return 0;
-    }
-    if (!strcmp(end, "c"))
-	mult = 1;
-    else if (!strcmp(end, "w"))
-	mult = 2;
-    else if (!strcmp(end, "b"))
-	mult = 512;
-    else if (!strcmp(end, "kB"))
-	mult = 1000;
-    else if (!strcmp(end, "K"))
-	mult = 1024;
-    else if (!strcmp(end, "MB"))
-	mult = (size_t)1000*1000;
-    else if (!strcmp(end, "M"))
-	mult = (size_t)1024*1024;
-    else if (!strcmp(end, "GB"))
-	mult = (size_t)1000*1000*1000;
-    else if (!strcmp(end, "G"))
-	mult = (size_t)1024*1024*1024;
-    else
-	return -1;
-
-    if (value > MAX_SIZE_T / mult)
-	return -1;
-    *size = value * mult;
-    return 0;
-}
-
-int main(int argc, char *argv[])
-{
-    char *suffix = DEFAULT_SUFFIX;
-    char *block_size_str = DEFAULT_BLOCK_SIZE;
-    char *chunk_size_str = DEFAULT_CHUNK_SIZE;
-    size_t block_size, chunk_size, blocks_per_chunk, to_write;
-    char *in_path, *out_path, *out_fmt;
-    int in_fd, out_fd;
-    struct stat in_st;
-    off_t left_to_write;
-    struct {
-	sparse_header_t sparse_hdr;
-	chunk_header_t dont_care_hdr;
-	chunk_header_t raw_hdr;
-    } file_hdr;
-    unsigned int file_count;
-    ssize_t s;
-    int i;
-
-    /* Parse the command line. */
-    while ((i = getopt(argc, argv, "s:B:C:")) != -1)
-    {
-	switch (i) {
-	case 's':
-	    suffix = optarg;
-	    break;
-	case 'B':
-	    block_size_str = optarg;
-	    break;
-	case 'C':
-	    chunk_size_str = optarg;
-	    break;
-	default:
-	    usage(argv[0], NULL);
-	    break;
-	}
-    }
-
-    if (parse_size(block_size_str, &block_size))
-	usage(argv[0], "Can not parse \"%s\" as a block size.",
-	      block_size_str);
-    if (block_size % 4096)
-	usage(argv[0], "Block size is not a multiple of 4096.");
-
-    if (parse_size(chunk_size_str, &chunk_size))
-	usage(argv[0], "Can not parse \"%s\" as a chunk size.",
-	      chunk_size_str);
-    if (chunk_size % block_size)
-	usage(argv[0], "Chunk size is not a multiple of the block size.");
-    blocks_per_chunk = chunk_size / block_size;
-
-    if ((argc - optind) != 1)
-	usage(argv[0], "Missing or extra arguments.");
-    in_path = argv[optind];
-
-    /* Open the input file and validate it. */
-    if ((in_fd = open(in_path, O_RDONLY)) < 0)
-	error_exit("open \"%s\": %s", in_path, strerror(errno));
-    if (fstat(in_fd, &in_st))
-	error_exit("fstat \"%s\": %s", in_path, strerror(errno));
-    left_to_write = in_st.st_size;
-    if (left_to_write % block_size)
-	error_exit(
-	    "\"%s\" size (%llu) is not a multiple of the block size (%llu).\n",
-	    in_path,
-	    (unsigned long long)left_to_write, (unsigned long long)block_size);
-
-    /* Get a buffer for copying the chunks. */
-    if ((copy_buf = malloc(COPY_BUF_SIZE)) == 0)
-	error_exit("malloc copy buffer: %s", strerror(errno));
-
-    /* Get a buffer for a sprintf format to form output paths. */
-    if ((out_fmt = malloc(sizeof("%s") + strlen(suffix))) == 0)
-	error_exit("malloc format buffer: %s", strerror(errno));
-    out_fmt[0] = '%';
-    out_fmt[1] = 's';
-    strcpy(out_fmt + 2, suffix);
-
-    /* Get a buffer for an output path. */
-    i = snprintf(copy_buf, COPY_BUF_SIZE, out_fmt, in_path, UINT_MAX);
-    if (i >= COPY_BUF_SIZE)
-	error_exit("Ridulously long suffix: %s", suffix);
-    if ((out_path = malloc(i + 1)) == 0)
-	error_exit("malloc output path buffer: %s", strerror(errno));
-
-    /*
-     * Each file gets a sparse_header, a Don't Care chunk to offset to
-     * where the data belongs and then a Raw chunk with the actual data.
-     */
-    memset((void *)&file_hdr.sparse_hdr, 0, sizeof(file_hdr.sparse_hdr));
-    file_hdr.sparse_hdr.magic = my_htole32(SPARSE_HEADER_MAGIC);
-    file_hdr.sparse_hdr.major_version = my_htole16(1);
-    file_hdr.sparse_hdr.minor_version = my_htole16(0);
-    file_hdr.sparse_hdr.file_hdr_sz = my_htole16(sizeof(sparse_header_t));
-    file_hdr.sparse_hdr.chunk_hdr_sz = my_htole16(sizeof(chunk_header_t));
-    file_hdr.sparse_hdr.blk_sz = my_htole32(block_size);
-    /* The total_blks will be set in the file loop below. */
-    file_hdr.sparse_hdr.total_chunks = my_htole32(2);
-    file_hdr.sparse_hdr.image_checksum = my_htole32(0); /* Typically unused. */
-
-    memset((void *)&file_hdr.dont_care_hdr, 0, sizeof(file_hdr.dont_care_hdr));
-    file_hdr.dont_care_hdr.chunk_type = my_htole16(CHUNK_TYPE_DONT_CARE);
-    /* The Don't Care's chunk_sz will be set in the file loop below. */
-    file_hdr.dont_care_hdr.total_sz = my_htole32(sizeof(chunk_header_t));
-
-    memset((void *)&file_hdr.raw_hdr, 0, sizeof(file_hdr.raw_hdr));
-    file_hdr.raw_hdr.chunk_type = my_htole16(CHUNK_TYPE_RAW);
-    file_hdr.raw_hdr.chunk_sz = my_htole32(blocks_per_chunk);
-    file_hdr.raw_hdr.total_sz = my_htole32(chunk_size + sizeof(chunk_header_t));
-
-    /* Loop through writing chunk_size to each of the output files. */
-    to_write = chunk_size;
-    for (file_count = 1; left_to_write ; file_count++) {
-	/* Fix up the headers on the last block. */
-	if (left_to_write < (off_t)chunk_size) {
-	    to_write = left_to_write;
-	    file_hdr.raw_hdr.chunk_sz = my_htole32(left_to_write / block_size);
-	    file_hdr.raw_hdr.total_sz = my_htole32(left_to_write
-						+ sizeof(chunk_header_t));
-	}
-
-	/* Form the pathname for this output file and open it. */
-	sprintf(out_path, out_fmt, in_path, file_count);
-	if ((out_fd = creat(out_path, 0666)) < 0)
-	    error_exit("\"%s\": %s", out_path, strerror(errno));
-
-	/* Update and write the headers to this output file. */
-	s = (file_count-1) * blocks_per_chunk;
-	file_hdr.dont_care_hdr.chunk_sz = my_htole32(s);
-	file_hdr.sparse_hdr.total_blks = my_htole32(s
-						+ (to_write / block_size));
-	s = write(out_fd, (void *)&file_hdr, sizeof(file_hdr));
-	if (s < 0)
-	    error_exit("\"%s\": %s", out_path, strerror(errno));
-	if (s != sizeof(file_hdr))
-	    error_exit("\"%s\": Short write (%lu)", out_path, (unsigned long)s);
-
-	/* Copy this chunk from the input file to the output file. */
-	cpy_file(out_fd, out_path, in_fd, in_path, to_write);
-
-	/* Close this output file and update the amount left to write. */
-	if (close(out_fd))
-	    error_exit("close \"%s\": %s", out_path, strerror(errno));
-	left_to_write -= to_write;
-    }
-
-    if (close(in_fd))
-	error_exit("close \"%s\": %s", in_path, strerror(errno));
-
-    exit(EXIT_SUCCESS);
-}
diff --git a/img2simg_main.c b/img2simg_main.c
new file mode 100644
index 0000000..826b068
--- /dev/null
+++ b/img2simg_main.c
@@ -0,0 +1,330 @@
+/*
+ * Copyright (C) 2010-2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define DEFAULT_BLOCK_SIZE	"4K"
+#define DEFAULT_CHUNK_SIZE	"64M"
+#define DEFAULT_SUFFIX		"%03d"
+
+#include "ext4_utils.h"
+#include "sparse_format.h"
+#if 0 /* endian.h is not on all platforms */
+# include <endian.h>
+#else
+  /* For now, just assume we're going to run on little-endian. */
+# define my_htole32(h) (h)
+# define my_htole16(h) (h)
+#endif
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#define COPY_BUF_SIZE (1024*1024)
+static char *copy_buf;
+
+static const char *progname(const char *argv0)
+{
+    const char *prog_name;
+    if ((prog_name = strrchr(argv0, '/')))
+	return(prog_name + 1);	/* Advance beyond '/'. */
+    return(argv0);		/* No '/' in argv0, use it as is. */
+}
+
+static void error_exit(const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    vfprintf(stderr, fmt, ap);
+    fputc('\n', stderr);
+    va_end(ap);
+
+    exit(EXIT_FAILURE);
+}
+
+static void usage(const char *argv0, const char *error_fmt, ...)
+{
+    fprintf(stderr,
+	    "Usage: %s [OPTIONS] <raw_image_file>\n",
+	    progname(argv0));
+    fprintf(stderr, "The <raw_image_file> will be split into as many sparse\n");
+    fprintf(stderr, "files as needed.  Each sparse file will contain a single\n");
+    fprintf(stderr, "DONT CARE chunk to offset to the correct block and then\n");
+    fprintf(stderr, "a single RAW chunk containing a portion of the data from\n");
+    fprintf(stderr, "the raw image file.  The sparse files will be named by\n");
+    fprintf(stderr, "appending a number to the name of the raw image file.\n");
+    fprintf(stderr, "\n");
+    fprintf(stderr, "OPTIONS (Defaults are enclosed by square brackets):\n");
+    fprintf(stderr, "  -s SUFFIX      Format appended number with SUFFIX [%s]\n",
+	    DEFAULT_SUFFIX);
+    fprintf(stderr, "  -B SIZE        Use a block size of SIZE [%s]\n",
+	    DEFAULT_BLOCK_SIZE);
+    fprintf(stderr, "  -C SIZE        Use a chunk size of SIZE [%s]\n",
+	    DEFAULT_CHUNK_SIZE);
+    fprintf(stderr, "SIZE is a decimal integer that may optionally be\n");
+    fprintf(stderr, "followed by a suffix that specifies a multiplier for\n");
+    fprintf(stderr, "the integer:\n");
+    fprintf(stderr, "       c         1 byte (the default when omitted)\n");
+    fprintf(stderr, "       w         2 bytes\n");
+    fprintf(stderr, "       b         512 bytes\n");
+    fprintf(stderr, "       kB        1000 bytes\n");
+    fprintf(stderr, "       K         1024 bytes\n");
+    fprintf(stderr, "       MB        1000*1000 bytes\n");
+    fprintf(stderr, "       M         1024*1024 bytes\n");
+    fprintf(stderr, "       GB        1000*1000*1000 bytes\n");
+    fprintf(stderr, "       G         1024*1024*1024 bytes\n");
+
+    if (error_fmt && *error_fmt)
+    {
+	fprintf(stderr, "\n");
+	va_list ap;
+	va_start(ap, error_fmt);
+	vfprintf(stderr, error_fmt, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+    }
+
+    exit(EXIT_FAILURE);
+}
+
+static void cpy_file(int out_fd, char *out_path, int in_fd, char *in_path,
+		     size_t len)
+{
+    ssize_t s, cpy_len = COPY_BUF_SIZE;
+
+    while (len) {
+	if (len < COPY_BUF_SIZE)
+	    cpy_len = len;
+
+	s = read(in_fd, copy_buf, cpy_len);
+	if (s < 0)
+	    error_exit("\"%s\": %s", in_path, strerror(errno));
+	if (!s)
+	    error_exit("\"%s\": Unexpected EOF", in_path);
+
+	cpy_len = s;
+
+	s = write(out_fd, copy_buf, cpy_len);
+	if (s < 0)
+	    error_exit("\"%s\": %s", out_path, strerror(errno));
+	if (s != cpy_len)
+	    error_exit("\"%s\": Short data write (%lu)", out_path,
+		       (unsigned long)s);
+
+	len -= cpy_len;
+    }
+}
+
+static int parse_size(const char *size_str, size_t *size)
+{
+    static const size_t MAX_SIZE_T = ~(size_t)0;
+    size_t mult;
+    unsigned long long int value;
+    const char *end;
+    errno = 0;
+    value = strtoull(size_str, (char **)&end, 10);
+    if (errno != 0 || end == size_str || value > MAX_SIZE_T)
+	return -1;
+    if (*end == '\0') {
+	*size = value;
+	return 0;
+    }
+    if (!strcmp(end, "c"))
+	mult = 1;
+    else if (!strcmp(end, "w"))
+	mult = 2;
+    else if (!strcmp(end, "b"))
+	mult = 512;
+    else if (!strcmp(end, "kB"))
+	mult = 1000;
+    else if (!strcmp(end, "K"))
+	mult = 1024;
+    else if (!strcmp(end, "MB"))
+	mult = (size_t)1000*1000;
+    else if (!strcmp(end, "M"))
+	mult = (size_t)1024*1024;
+    else if (!strcmp(end, "GB"))
+	mult = (size_t)1000*1000*1000;
+    else if (!strcmp(end, "G"))
+	mult = (size_t)1024*1024*1024;
+    else
+	return -1;
+
+    if (value > MAX_SIZE_T / mult)
+	return -1;
+    *size = value * mult;
+    return 0;
+}
+
+int main(int argc, char *argv[])  /* 把一个文件分隔成多个小块 */
+{
+    char *suffix = DEFAULT_SUFFIX;
+    char *block_size_str = DEFAULT_BLOCK_SIZE;
+    char *chunk_size_str = DEFAULT_CHUNK_SIZE;
+    size_t block_size, chunk_size, blocks_per_chunk, to_write;
+    char *in_path, *out_path, *out_fmt;
+    int in_fd, out_fd;
+    struct stat in_st;
+    off_t left_to_write;
+    struct {
+	sparse_header_t sparse_hdr;
+	chunk_header_t dont_care_hdr;
+	chunk_header_t raw_hdr;
+    } file_hdr;
+    unsigned int file_count;
+    ssize_t s;
+    int i;
+
+    /* Parse the command line. */
+    while ((i = getopt(argc, argv, "s:B:C:")) != -1)
+    {
+	switch (i) {
+	case 's':
+	    suffix = optarg;
+	    break;
+	case 'B':
+	    block_size_str = optarg;
+	    break;
+	case 'C':
+	    chunk_size_str = optarg;
+	    break;
+	default:
+	    usage(argv[0], NULL);
+	    break;
+	}
+    }
+
+    if (parse_size(block_size_str, &block_size))
+	usage(argv[0], "Can not parse \"%s\" as a block size.",
+	      block_size_str);
+    if (block_size % 4096)
+	usage(argv[0], "Block size is not a multiple of 4096.");
+
+    if (parse_size(chunk_size_str, &chunk_size))
+	usage(argv[0], "Can not parse \"%s\" as a chunk size.",
+	      chunk_size_str);
+    if (chunk_size % block_size)
+	usage(argv[0], "Chunk size is not a multiple of the block size.");
+    blocks_per_chunk = chunk_size / block_size;
+
+    if ((argc - optind) != 1)
+	usage(argv[0], "Missing or extra arguments.");
+    in_path = argv[optind];
+
+    /* Open the input file and validate it. */
+    if ((in_fd = open(in_path, O_RDONLY)) < 0)
+	error_exit("open \"%s\": %s", in_path, strerror(errno));
+    if (fstat(in_fd, &in_st))
+	error_exit("fstat \"%s\": %s", in_path, strerror(errno));
+    left_to_write = in_st.st_size; /* 得到文件大小 */
+    if (left_to_write % block_size)
+	error_exit(
+	    "\"%s\" size (%llu) is not a multiple of the block size (%llu).\n",
+	    in_path,
+	    (unsigned long long)left_to_write, (unsigned long long)block_size);
+
+    /* Get a buffer for copying the chunks. */
+    if ((copy_buf = malloc(COPY_BUF_SIZE)) == 0)
+	error_exit("malloc copy buffer: %s", strerror(errno));
+
+    /* Get a buffer for a sprintf format to form output paths. */
+    if ((out_fmt = malloc(sizeof("%s") + strlen(suffix))) == 0)
+	error_exit("malloc format buffer: %s", strerror(errno));
+    out_fmt[0] = '%';
+    out_fmt[1] = 's';
+    strcpy(out_fmt + 2, suffix);
+
+    /* Get a buffer for an output path. */
+    i = snprintf(copy_buf, COPY_BUF_SIZE, out_fmt, in_path, UINT_MAX);
+    if (i >= COPY_BUF_SIZE)
+	error_exit("Ridulously long suffix: %s", suffix);
+    if ((out_path = malloc(i + 1)) == 0)
+	error_exit("malloc output path buffer: %s", strerror(errno));
+
+    /*
+     * Each file gets a sparse_header, a Don't Care chunk to offset to
+     * where the data belongs and then a Raw chunk with the actual data.
+     */
+    memset((void *)&file_hdr.sparse_hdr, 0, sizeof(file_hdr.sparse_hdr));
+    file_hdr.sparse_hdr.magic = my_htole32(SPARSE_HEADER_MAGIC);
+    file_hdr.sparse_hdr.major_version = my_htole16(1);
+    file_hdr.sparse_hdr.minor_version = my_htole16(0);
+    file_hdr.sparse_hdr.file_hdr_sz = my_htole16(sizeof(sparse_header_t));
+    file_hdr.sparse_hdr.chunk_hdr_sz = my_htole16(sizeof(chunk_header_t));
+    file_hdr.sparse_hdr.blk_sz = my_htole32(block_size);
+    /* The total_blks will be set in the file loop below. */
+    file_hdr.sparse_hdr.total_chunks = my_htole32(2);
+    file_hdr.sparse_hdr.image_checksum = my_htole32(0); /* Typically unused. */
+
+    memset((void *)&file_hdr.dont_care_hdr, 0, sizeof(file_hdr.dont_care_hdr));
+    file_hdr.dont_care_hdr.chunk_type = my_htole16(CHUNK_TYPE_DONT_CARE);
+    /* The Don't Care's chunk_sz will be set in the file loop below. */
+    file_hdr.dont_care_hdr.total_sz = my_htole32(sizeof(chunk_header_t));
+
+    memset((void *)&file_hdr.raw_hdr, 0, sizeof(file_hdr.raw_hdr));
+    file_hdr.raw_hdr.chunk_type = my_htole16(CHUNK_TYPE_RAW);
+    file_hdr.raw_hdr.chunk_sz = my_htole32(blocks_per_chunk);
+    file_hdr.raw_hdr.total_sz = my_htole32(chunk_size + sizeof(chunk_header_t));
+
+    /* Loop through writing chunk_size to each of the output files. */
+    to_write = chunk_size;
+
+    /* 每次处理一个块 */
+    for (file_count = 1; left_to_write ; file_count++) {
+	/* Fix up the headers on the last block. */
+	if (left_to_write < (off_t)chunk_size) {
+	    to_write = left_to_write;
+	    file_hdr.raw_hdr.chunk_sz = my_htole32(left_to_write / block_size);
+	    file_hdr.raw_hdr.total_sz = my_htole32(left_to_write
+						+ sizeof(chunk_header_t));
+	}
+
+	/* Form the pathname for this output file and open it. */
+	sprintf(out_path, out_fmt, in_path, file_count);
+	if ((out_fd = creat(out_path, 0666)) < 0)
+	    error_exit("\"%s\": %s", out_path, strerror(errno));
+
+	/* Update and write the headers to this output file. */
+	s = (file_count-1) * blocks_per_chunk;
+	file_hdr.dont_care_hdr.chunk_sz = my_htole32(s);
+	file_hdr.sparse_hdr.total_blks = my_htole32(s
+						+ (to_write / block_size));
+	s = write(out_fd, (void *)&file_hdr, sizeof(file_hdr));
+	if (s < 0)
+	    error_exit("\"%s\": %s", out_path, strerror(errno));
+	if (s != sizeof(file_hdr))
+	    error_exit("\"%s\": Short write (%lu)", out_path, (unsigned long)s);
+
+	/* Copy this chunk from the input file to the output file. */
+	cpy_file(out_fd, out_path, in_fd, in_path, to_write);
+
+	/* Close this output file and update the amount left to write. */
+	if (close(out_fd))
+	    error_exit("close \"%s\": %s", out_path, strerror(errno));
+	left_to_write -= to_write;
+    }
+
+    if (close(in_fd))
+	error_exit("close \"%s\": %s", in_path, strerror(errno));
+
+    exit(EXIT_SUCCESS);
+}
diff --git a/make_ext4fs.c b/make_ext4fs.c
index 6cd5ade..3768b77 100644
--- a/make_ext4fs.c
+++ b/make_ext4fs.c
@@ -33,35 +33,8 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#ifdef USE_MINGW
-
-#include <winsock2.h>
-
-/* These match the Linux definitions of these flags.
-   L_xx is defined to avoid conflicting with the win32 versions.
-*/
-#define L_S_IRUSR 00400
-#define L_S_IWUSR 00200
-#define L_S_IXUSR 00100
-#define S_IRWXU (L_S_IRUSR | L_S_IWUSR | L_S_IXUSR)
-#define S_IRGRP 00040
-#define S_IWGRP 00020
-#define S_IXGRP 00010
-#define S_IRWXG (S_IRGRP | S_IWGRP | S_IXGRP)
-#define S_IROTH 00004
-#define S_IWOTH 00002
-#define S_IXOTH 00001
-#define S_IRWXO (S_IROTH | S_IWOTH | S_IXOTH)
-#define S_ISUID 0004000
-#define S_ISGID 0002000
-#define S_ISVTX 0001000
-
-#else
-
 #define O_BINARY 0
 
-#endif
-
 /* TODO: Not implemented:
    Allocating blocks in the same block group as the file inode
    Hash or binary tree directories
@@ -94,7 +67,6 @@ static u32 build_default_directory_structure()
 	return root_inode;
 }
 
-#ifndef USE_MINGW
 /* Read a local directory and create the same tree in the generated filesystem.
    Calls itself recursively with each directory in the given directory */
 static u32 build_directory_structure(const char *full_path, const char *dir_path,
@@ -143,7 +115,6 @@ static u32 build_directory_structure(const char *full_path, const char *dir_path
 		dentries[i].mode = stat.st_mode & (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO);
 		dentries[i].mtime = stat.st_mtime;
 		if (fs_config_func != NULL) {
-#ifdef ANDROID
 			unsigned int mode = 0;
 			unsigned int uid = 0;
 			unsigned int gid = 0;
@@ -152,22 +123,7 @@ static u32 build_directory_structure(const char *full_path, const char *dir_path
 			dentries[i].mode = mode;
 			dentries[i].uid = uid;
 			dentries[i].gid = gid;
-#else
-			error("can't set android permissions - built without android support");
-#endif
 		}
-#ifdef HAVE_SELINUX
-		if (sehnd) {
-			char *sepath = NULL;
-			asprintf(&sepath, "/%s", dentries[i].path);
-			if (selabel_lookup(sehnd, &dentries[i].secon, sepath, stat.st_mode) < 0) {
-				error("cannot lookup security context for %s", sepath);
-			}
-			if (dentries[i].secon)
-				printf("Labeling %s as %s\n", sepath, dentries[i].secon);
-			free(sepath);
-		}
-#endif
 
 		if (S_ISREG(stat.st_mode)) {
 			dentries[i].file_type = EXT4_FT_REG_FILE;
@@ -204,6 +160,8 @@ static u32 build_directory_structure(const char *full_path, const char *dir_path
 					dentries[i].path, inode, fs_config_func, sehnd);
 		} else if (dentries[i].file_type == EXT4_FT_SYMLINK) {
 			entry_inode = make_link(dentries[i].full_path, dentries[i].link);
+		} else if (dentries[i].file_type == EXT4_FT_CHRDEV) {
+			entry_inode = make_chrdev(dentries[i].full_path, (u64)dentries[i].size);
 		} else {
 			error("unknown file type on %s", dentries[i].path);
 			entry_inode = 0;
@@ -229,7 +187,6 @@ static u32 build_directory_structure(const char *full_path, const char *dir_path
 	free(dentries);
 	return inode;
 }
-#endif
 
 static u32 compute_block_size()
 {
@@ -405,44 +362,15 @@ int make_ext4fs_internal(int fd, const char *directory,
 	if (info.feat_compat & EXT4_FEATURE_COMPAT_RESIZE_INODE)
 		ext4_create_resize_inode();
 
-#ifdef USE_MINGW
-	// Windows needs only 'create an empty fs image' functionality
-	assert(!directory);
-	root_inode_num = build_default_directory_structure();
-#else
 	if (directory)
 		root_inode_num = build_directory_structure(directory, mountpoint, 0,
                         fs_config_func, sehnd);
 	else
 		root_inode_num = build_default_directory_structure();
-#endif
 
 	root_mode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
 	inode_set_permissions(root_inode_num, root_mode, 0, 0, 0);
 
-#ifdef HAVE_SELINUX
-	if (sehnd) {
-		char *sepath = NULL;
-		char *secontext = NULL;
-
-		if (mountpoint[0] == '/')
-			sepath = strdup(mountpoint);
-		else
-			asprintf(&sepath, "/%s", mountpoint);
-		if (!sepath)
-			critical_error_errno("malloc");
-		if (selabel_lookup(sehnd, &secontext, sepath, S_IFDIR) < 0) {
-			error("cannot lookup security context for %s", sepath);
-		}
-		if (secontext) {
-			printf("Labeling %s as %s\n", sepath, secontext);
-			inode_set_selinux(root_inode_num, secontext);
-		}
-		free(sepath);
-		freecon(secontext);
-	}
-#endif
-
 	ext4_update_free();
 
 	if (init_itabs)
diff --git a/make_ext4fs.h b/make_ext4fs.h
index c217c3d..1c9ccb3 100644
--- a/make_ext4fs.h
+++ b/make_ext4fs.h
@@ -24,12 +24,7 @@
 extern "C" {
 #endif
 
-#ifdef HAVE_SELINUX
-#include <selinux/selinux.h>
-#include <selinux/label.h>
-#else
 struct selabel_handle;
-#endif
 
 typedef void (*fs_config_func_t)(const char *path, int dir, unsigned *uid, unsigned *gid,
         unsigned *mode);
diff --git a/make_ext4fs_main.c b/make_ext4fs_main.c
index d545423..171d676 100644
--- a/make_ext4fs_main.c
+++ b/make_ext4fs_main.c
@@ -24,15 +24,11 @@
 #include <sys/disk.h>
 #endif
 
-#ifdef ANDROID
-#include <private/android_filesystem_config.h>
-#endif
+#include "android_filesystem_config.h"
 
 #include "make_ext4fs.h"
 
-#ifndef USE_MINGW /* O_BINARY is windows-specific flag */
 #define O_BINARY 0
-#endif
 
 extern struct fs_info info;
 
@@ -62,9 +58,6 @@ int main(int argc, char **argv)
 	int fd;
 	int exitcode;
 	struct selabel_handle *sehnd = NULL;
-#ifdef HAVE_SELINUX
-	struct selinux_opt seopts[] = { { SELABEL_OPT_PATH, "" } };
-#endif
 
 	while ((opt = getopt(argc, argv, "l:j:b:g:i:I:L:a:fwzJsctS:")) != -1) {
 		switch (opt) {
@@ -93,14 +86,8 @@ int main(int argc, char **argv)
 			force = 1;
 			break;
 		case 'a':
-#ifdef ANDROID
 			fs_config_func = fs_config;
 			mountpoint = optarg;
-#else
-			fprintf(stderr, "can't set android permissions - built without android support\n");
-			usage(argv[0]);
-			exit(EXIT_FAILURE);
-#endif
 			break;
 		case 'w':
 			wipe = 1;
@@ -121,14 +108,6 @@ int main(int argc, char **argv)
 			init_itabs = 1;
 			break;
 		case 'S':
-#ifdef HAVE_SELINUX
-			seopts[0].value = optarg;
-			sehnd = selabel_open(SELABEL_CTX_FILE, seopts, 1);
-			if (!sehnd) {
-				perror(optarg);
-				exit(EXIT_FAILURE);
-			}
-#endif
 			   break;
 		default: /* '?' */
 			usage(argv[0]);
diff --git a/output_file.c b/output_file.c
index 40655a9..81d8f85 100644
--- a/output_file.c
+++ b/output_file.c
@@ -28,10 +28,8 @@
 #include <unistd.h>
 #include <zlib.h>
 
-#ifndef USE_MINGW
 #include <sys/mman.h>
 #define O_BINARY 0
-#endif
 
 
 #if defined(__APPLE__) && defined(__MACH__)
@@ -557,7 +555,6 @@ void write_data_file(struct output_file *out, u64 off, const char *file,
 	aligned_diff = offset - aligned_offset;
 	buffer_size = len + aligned_diff;
 
-#ifndef USE_MINGW
 	u8 *data = mmap64(NULL, buffer_size, PROT_READ, MAP_SHARED, file_fd,
 			aligned_offset);
 	if (data == MAP_FAILED) {
@@ -565,15 +562,6 @@ void write_data_file(struct output_file *out, u64 off, const char *file,
 		close(file_fd);
 		return;
 	}
-#else
-	u8 *data = malloc(buffer_size);
-	if (!data) {
-		error_errno("malloc");
-		close(file_fd);
-		return;
-	}
-	memset(data, 0, buffer_size);
-#endif
 
 	if (out->sparse) {
 		write_chunk_raw(out, off, data + aligned_diff, len);
@@ -588,11 +576,6 @@ void write_data_file(struct output_file *out, u64 off, const char *file,
 	}
 
 err:
-#ifndef USE_MINGW
 	munmap(data, buffer_size);
-#else
-	write(file_fd, data, buffer_size);
-	free(data);
-#endif
 	close(file_fd);
 }
diff --git a/sha1.c b/sha1.c
index 463ec38..1db9134 100644
--- a/sha1.c
+++ b/sha1.c
@@ -17,9 +17,7 @@
 
 #define SHA1HANDSOFF		/* Copies data before messing with it. */
 
-#ifndef USE_MINGW
 #include <sys/cdefs.h>
-#endif
 #include <sys/types.h>
 #include <assert.h>
 #include <string.h>
diff --git a/sha1.h b/sha1.h
index 9a8f7e3..77a8747 100644
--- a/sha1.h
+++ b/sha1.h
@@ -11,18 +11,7 @@
 
 #include <sys/types.h>
 #include <stdint.h>
-
-#ifdef USE_MINGW
-typedef unsigned char u_char;
-typedef unsigned int uint32_t;
-typedef unsigned int u_int32_t;
-typedef unsigned int u_int;
-
-#define __BEGIN_DECLS
-#define __END_DECLS
-#else
 #include <sys/cdefs.h>
-#endif
 
 #define SHA1_DIGEST_LENGTH		20
 #define SHA1_DIGEST_STRING_LENGTH	41
diff --git a/simg2img.c b/simg2img.c
deleted file mode 100644
index 12b92eb..0000000
--- a/simg2img.c
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "ext4_utils.h"
-#include "sparse_format.h"
-#include "sparse_crc32.h"
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdio.h>
-
-#define COPY_BUF_SIZE (1024*1024)
-u8 *copybuf;
-
-/* This will be malloc'ed with the size of blk_sz from the sparse file header */
-u8* zerobuf;
-
-#define SPARSE_HEADER_MAJOR_VER 1
-#define SPARSE_HEADER_LEN       (sizeof(sparse_header_t))
-#define CHUNK_HEADER_LEN (sizeof(chunk_header_t))
-
-void usage()
-{
-  fprintf(stderr, "Usage: simg2img <sparse_image_file> <raw_image_file>\n");
-}
-
-static int read_all(int fd, void *buf, size_t len)
-{
-	size_t total = 0;
-	int ret;
-	char *ptr = buf;
-
-	while (total < len) {
-		ret = read(fd, ptr, len - total);
-
-		if (ret < 0)
-			return ret;
-
-		if (ret == 0)
-			return total;
-
-		ptr += ret;
-		total += ret;
-	}
-
-	return total;
-}
-
-static int write_all(int fd, void *buf, size_t len)
-{
-	size_t total = 0;
-	int ret;
-	char *ptr = buf;
-
-	while (total < len) {
-		ret = write(fd, ptr, len - total);
-
-		if (ret < 0)
-			return ret;
-
-		if (ret == 0)
-			return total;
-
-		ptr += ret;
-		total += ret;
-	}
-
-	return total;
-}
-
-int process_raw_chunk(int in, int out, u32 blocks, u32 blk_sz, u32 *crc32)
-{
-	u64 len = (u64)blocks * blk_sz;
-	int ret;
-	int chunk;
-
-	while (len) {
-		chunk = (len > COPY_BUF_SIZE) ? COPY_BUF_SIZE : len;
-		ret = read_all(in, copybuf, chunk);
-		if (ret != chunk) {
-			fprintf(stderr, "read returned an error copying a raw chunk: %d %d\n",
-					ret, chunk);
-			exit(-1);
-		}
-		*crc32 = sparse_crc32(*crc32, copybuf, chunk);
-		ret = write_all(out, copybuf, chunk);
-		if (ret != chunk) {
-			fprintf(stderr, "write returned an error copying a raw chunk\n");
-			exit(-1);
-		}
-		len -= chunk;
-	}
-
-	return blocks;
-}
-
-
-int process_fill_chunk(int in, int out, u32 blocks, u32 blk_sz, u32 *crc32)
-{
-	u64 len = (u64)blocks * blk_sz;
-	int ret;
-	int chunk;
-	u32 fill_val;
-	u32 *fillbuf;
-	unsigned int i;
-
-	/* Fill copy_buf with the fill value */
-	ret = read_all(in, &fill_val, sizeof(fill_val));
-	fillbuf = (u32 *)copybuf;
-	for (i = 0; i < (COPY_BUF_SIZE / sizeof(fill_val)); i++) {
-		fillbuf[i] = fill_val;
-	}
-
-	while (len) {
-		chunk = (len > COPY_BUF_SIZE) ? COPY_BUF_SIZE : len;
-		*crc32 = sparse_crc32(*crc32, copybuf, chunk);
-		ret = write_all(out, copybuf, chunk);
-		if (ret != chunk) {
-			fprintf(stderr, "write returned an error copying a raw chunk\n");
-			exit(-1);
-		}
-		len -= chunk;
-	}
-
-	return blocks;
-}
-
-int process_skip_chunk(int out, u32 blocks, u32 blk_sz, u32 *crc32)
-{
-	/* len needs to be 64 bits, as the sparse file specifies the skip amount
-	 * as a 32 bit value of blocks.
-	 */
-	u64 len = (u64)blocks * blk_sz;
-
-	lseek64(out, len, SEEK_CUR);
-
-	return blocks;
-}
-
-int process_crc32_chunk(int in, u32 crc32)
-{
-	u32 file_crc32;
-	int ret;
-
-	ret = read_all(in, &file_crc32, 4);
-	if (ret != 4) {
-		fprintf(stderr, "read returned an error copying a crc32 chunk\n");
-		exit(-1);
-	}
-
-	if (file_crc32 != crc32) {
-		fprintf(stderr, "computed crc32 of 0x%8.8x, expected 0x%8.8x\n",
-			 crc32, file_crc32);
-		exit(-1);
-	}
-
-	return 0;
-}
-
-int main(int argc, char *argv[])
-{
-	int in;
-	int out;
-	unsigned int i;
-	sparse_header_t sparse_header;
-	chunk_header_t chunk_header;
-	u32 crc32 = 0;
-	u32 total_blocks = 0;
-	int ret;
-
-	if (argc != 3) {
-		usage();
-		exit(-1);
-	}
-
-	if ( (copybuf = malloc(COPY_BUF_SIZE)) == 0) {
-		fprintf(stderr, "Cannot malloc copy buf\n");
-		exit(-1);
-	}
-
-	if (strcmp(argv[1], "-") == 0) {
-		in = STDIN_FILENO;
-	} else {
-		if ((in = open(argv[1], O_RDONLY)) == 0) {
-			fprintf(stderr, "Cannot open input file %s\n", argv[1]);
-			exit(-1);
-		}
-	}
-
-	if (strcmp(argv[2], "-") == 0) {
-		out = STDOUT_FILENO;
-	} else {
-		if ((out = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0666)) == 0) {
-			fprintf(stderr, "Cannot open output file %s\n", argv[2]);
-			exit(-1);
-		}
-	}
-
-	ret = read_all(in, &sparse_header, sizeof(sparse_header));
-	if (ret != sizeof(sparse_header)) {
-		fprintf(stderr, "Error reading sparse file header\n");
-		exit(-1);
-	}
-
-	if (sparse_header.magic != SPARSE_HEADER_MAGIC) {
-		fprintf(stderr, "Bad magic\n");
-		exit(-1);
-	}
-
-	if (sparse_header.major_version != SPARSE_HEADER_MAJOR_VER) {
-		fprintf(stderr, "Unknown major version number\n");
-		exit(-1);
-	}
-
-	if (sparse_header.file_hdr_sz > SPARSE_HEADER_LEN) {
-		/* Skip the remaining bytes in a header that is longer than
-		 * we expected.
-		 */
-		lseek64(in, sparse_header.file_hdr_sz - SPARSE_HEADER_LEN, SEEK_CUR);
-	}
-
-	if ( (zerobuf = malloc(sparse_header.blk_sz)) == 0) {
-		fprintf(stderr, "Cannot malloc zero buf\n");
-		exit(-1);
-	}
-
-	for (i=0; i<sparse_header.total_chunks; i++) {
-		ret = read_all(in, &chunk_header, sizeof(chunk_header));
-		if (ret != sizeof(chunk_header)) {
-			fprintf(stderr, "Error reading chunk header\n");
-			exit(-1);
-		}
-
-		if (sparse_header.chunk_hdr_sz > CHUNK_HEADER_LEN) {
-			/* Skip the remaining bytes in a header that is longer than
-			 * we expected.
-			 */
-			lseek64(in, sparse_header.chunk_hdr_sz - CHUNK_HEADER_LEN, SEEK_CUR);
-		}
-
-		switch (chunk_header.chunk_type) {
-		    case CHUNK_TYPE_RAW:
-			if (chunk_header.total_sz != (sparse_header.chunk_hdr_sz +
-				 (chunk_header.chunk_sz * sparse_header.blk_sz)) ) {
-				fprintf(stderr, "Bogus chunk size for chunk %d, type Raw\n", i);
-				exit(-1);
-			}
-			total_blocks += process_raw_chunk(in, out,
-					 chunk_header.chunk_sz, sparse_header.blk_sz, &crc32);
-			break;
-		    case CHUNK_TYPE_FILL:
-			if (chunk_header.total_sz != (sparse_header.chunk_hdr_sz + sizeof(u32)) ) {
-				fprintf(stderr, "Bogus chunk size for chunk %d, type Fill\n", i);
-				exit(-1);
-			}
-			total_blocks += process_fill_chunk(in, out,
-					 chunk_header.chunk_sz, sparse_header.blk_sz, &crc32);
-			break;
-		    case CHUNK_TYPE_DONT_CARE:
-			if (chunk_header.total_sz != sparse_header.chunk_hdr_sz) {
-				fprintf(stderr, "Bogus chunk size for chunk %d, type Dont Care\n", i);
-				exit(-1);
-			}
-			total_blocks += process_skip_chunk(out,
-					 chunk_header.chunk_sz, sparse_header.blk_sz, &crc32);
-			break;
-		    case CHUNK_TYPE_CRC32:
-			process_crc32_chunk(in, crc32);
-			break;
-		    default:
-			fprintf(stderr, "Unknown chunk type 0x%4.4x\n", chunk_header.chunk_type);
-		}
-
-	}
-
-	/* If the last chunk was a skip, then the code just did a seek, but
-	 * no write, and the file won't actually be the correct size.  This
-	 * will make the file the correct size.  Make sure the offset is
-	 * computed in 64 bits, and the function called can handle 64 bits.
-	 */
-	if (ftruncate64(out, (u64)total_blocks * sparse_header.blk_sz)) {
-		fprintf(stderr, "Error calling ftruncate() to set the image size\n");
-		exit(-1);
-	}
-
-	close(in);
-	close(out);
-
-	if (sparse_header.total_blks != total_blocks) {
-		fprintf(stderr, "Wrote %d blocks, expected to write %d blocks\n",
-			 total_blocks, sparse_header.total_blks);
-		exit(-1);
-	}
-
-	exit(0);
-}
-
diff --git a/simg2img_main.c b/simg2img_main.c
new file mode 100644
index 0000000..12b92eb
--- /dev/null
+++ b/simg2img_main.c
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ext4_utils.h"
+#include "sparse_format.h"
+#include "sparse_crc32.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+
+#define COPY_BUF_SIZE (1024*1024)
+u8 *copybuf;
+
+/* This will be malloc'ed with the size of blk_sz from the sparse file header */
+u8* zerobuf;
+
+#define SPARSE_HEADER_MAJOR_VER 1
+#define SPARSE_HEADER_LEN       (sizeof(sparse_header_t))
+#define CHUNK_HEADER_LEN (sizeof(chunk_header_t))
+
+void usage()
+{
+  fprintf(stderr, "Usage: simg2img <sparse_image_file> <raw_image_file>\n");
+}
+
+static int read_all(int fd, void *buf, size_t len)
+{
+	size_t total = 0;
+	int ret;
+	char *ptr = buf;
+
+	while (total < len) {
+		ret = read(fd, ptr, len - total);
+
+		if (ret < 0)
+			return ret;
+
+		if (ret == 0)
+			return total;
+
+		ptr += ret;
+		total += ret;
+	}
+
+	return total;
+}
+
+static int write_all(int fd, void *buf, size_t len)
+{
+	size_t total = 0;
+	int ret;
+	char *ptr = buf;
+
+	while (total < len) {
+		ret = write(fd, ptr, len - total);
+
+		if (ret < 0)
+			return ret;
+
+		if (ret == 0)
+			return total;
+
+		ptr += ret;
+		total += ret;
+	}
+
+	return total;
+}
+
+int process_raw_chunk(int in, int out, u32 blocks, u32 blk_sz, u32 *crc32)
+{
+	u64 len = (u64)blocks * blk_sz;
+	int ret;
+	int chunk;
+
+	while (len) {
+		chunk = (len > COPY_BUF_SIZE) ? COPY_BUF_SIZE : len;
+		ret = read_all(in, copybuf, chunk);
+		if (ret != chunk) {
+			fprintf(stderr, "read returned an error copying a raw chunk: %d %d\n",
+					ret, chunk);
+			exit(-1);
+		}
+		*crc32 = sparse_crc32(*crc32, copybuf, chunk);
+		ret = write_all(out, copybuf, chunk);
+		if (ret != chunk) {
+			fprintf(stderr, "write returned an error copying a raw chunk\n");
+			exit(-1);
+		}
+		len -= chunk;
+	}
+
+	return blocks;
+}
+
+
+int process_fill_chunk(int in, int out, u32 blocks, u32 blk_sz, u32 *crc32)
+{
+	u64 len = (u64)blocks * blk_sz;
+	int ret;
+	int chunk;
+	u32 fill_val;
+	u32 *fillbuf;
+	unsigned int i;
+
+	/* Fill copy_buf with the fill value */
+	ret = read_all(in, &fill_val, sizeof(fill_val));
+	fillbuf = (u32 *)copybuf;
+	for (i = 0; i < (COPY_BUF_SIZE / sizeof(fill_val)); i++) {
+		fillbuf[i] = fill_val;
+	}
+
+	while (len) {
+		chunk = (len > COPY_BUF_SIZE) ? COPY_BUF_SIZE : len;
+		*crc32 = sparse_crc32(*crc32, copybuf, chunk);
+		ret = write_all(out, copybuf, chunk);
+		if (ret != chunk) {
+			fprintf(stderr, "write returned an error copying a raw chunk\n");
+			exit(-1);
+		}
+		len -= chunk;
+	}
+
+	return blocks;
+}
+
+int process_skip_chunk(int out, u32 blocks, u32 blk_sz, u32 *crc32)
+{
+	/* len needs to be 64 bits, as the sparse file specifies the skip amount
+	 * as a 32 bit value of blocks.
+	 */
+	u64 len = (u64)blocks * blk_sz;
+
+	lseek64(out, len, SEEK_CUR);
+
+	return blocks;
+}
+
+int process_crc32_chunk(int in, u32 crc32)
+{
+	u32 file_crc32;
+	int ret;
+
+	ret = read_all(in, &file_crc32, 4);
+	if (ret != 4) {
+		fprintf(stderr, "read returned an error copying a crc32 chunk\n");
+		exit(-1);
+	}
+
+	if (file_crc32 != crc32) {
+		fprintf(stderr, "computed crc32 of 0x%8.8x, expected 0x%8.8x\n",
+			 crc32, file_crc32);
+		exit(-1);
+	}
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	int in;
+	int out;
+	unsigned int i;
+	sparse_header_t sparse_header;
+	chunk_header_t chunk_header;
+	u32 crc32 = 0;
+	u32 total_blocks = 0;
+	int ret;
+
+	if (argc != 3) {
+		usage();
+		exit(-1);
+	}
+
+	if ( (copybuf = malloc(COPY_BUF_SIZE)) == 0) {
+		fprintf(stderr, "Cannot malloc copy buf\n");
+		exit(-1);
+	}
+
+	if (strcmp(argv[1], "-") == 0) {
+		in = STDIN_FILENO;
+	} else {
+		if ((in = open(argv[1], O_RDONLY)) == 0) {
+			fprintf(stderr, "Cannot open input file %s\n", argv[1]);
+			exit(-1);
+		}
+	}
+
+	if (strcmp(argv[2], "-") == 0) {
+		out = STDOUT_FILENO;
+	} else {
+		if ((out = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0666)) == 0) {
+			fprintf(stderr, "Cannot open output file %s\n", argv[2]);
+			exit(-1);
+		}
+	}
+
+	ret = read_all(in, &sparse_header, sizeof(sparse_header));
+	if (ret != sizeof(sparse_header)) {
+		fprintf(stderr, "Error reading sparse file header\n");
+		exit(-1);
+	}
+
+	if (sparse_header.magic != SPARSE_HEADER_MAGIC) {
+		fprintf(stderr, "Bad magic\n");
+		exit(-1);
+	}
+
+	if (sparse_header.major_version != SPARSE_HEADER_MAJOR_VER) {
+		fprintf(stderr, "Unknown major version number\n");
+		exit(-1);
+	}
+
+	if (sparse_header.file_hdr_sz > SPARSE_HEADER_LEN) {
+		/* Skip the remaining bytes in a header that is longer than
+		 * we expected.
+		 */
+		lseek64(in, sparse_header.file_hdr_sz - SPARSE_HEADER_LEN, SEEK_CUR);
+	}
+
+	if ( (zerobuf = malloc(sparse_header.blk_sz)) == 0) {
+		fprintf(stderr, "Cannot malloc zero buf\n");
+		exit(-1);
+	}
+
+	for (i=0; i<sparse_header.total_chunks; i++) {
+		ret = read_all(in, &chunk_header, sizeof(chunk_header));
+		if (ret != sizeof(chunk_header)) {
+			fprintf(stderr, "Error reading chunk header\n");
+			exit(-1);
+		}
+
+		if (sparse_header.chunk_hdr_sz > CHUNK_HEADER_LEN) {
+			/* Skip the remaining bytes in a header that is longer than
+			 * we expected.
+			 */
+			lseek64(in, sparse_header.chunk_hdr_sz - CHUNK_HEADER_LEN, SEEK_CUR);
+		}
+
+		switch (chunk_header.chunk_type) {
+		    case CHUNK_TYPE_RAW:
+			if (chunk_header.total_sz != (sparse_header.chunk_hdr_sz +
+				 (chunk_header.chunk_sz * sparse_header.blk_sz)) ) {
+				fprintf(stderr, "Bogus chunk size for chunk %d, type Raw\n", i);
+				exit(-1);
+			}
+			total_blocks += process_raw_chunk(in, out,
+					 chunk_header.chunk_sz, sparse_header.blk_sz, &crc32);
+			break;
+		    case CHUNK_TYPE_FILL:
+			if (chunk_header.total_sz != (sparse_header.chunk_hdr_sz + sizeof(u32)) ) {
+				fprintf(stderr, "Bogus chunk size for chunk %d, type Fill\n", i);
+				exit(-1);
+			}
+			total_blocks += process_fill_chunk(in, out,
+					 chunk_header.chunk_sz, sparse_header.blk_sz, &crc32);
+			break;
+		    case CHUNK_TYPE_DONT_CARE:
+			if (chunk_header.total_sz != sparse_header.chunk_hdr_sz) {
+				fprintf(stderr, "Bogus chunk size for chunk %d, type Dont Care\n", i);
+				exit(-1);
+			}
+			total_blocks += process_skip_chunk(out,
+					 chunk_header.chunk_sz, sparse_header.blk_sz, &crc32);
+			break;
+		    case CHUNK_TYPE_CRC32:
+			process_crc32_chunk(in, crc32);
+			break;
+		    default:
+			fprintf(stderr, "Unknown chunk type 0x%4.4x\n", chunk_header.chunk_type);
+		}
+
+	}
+
+	/* If the last chunk was a skip, then the code just did a seek, but
+	 * no write, and the file won't actually be the correct size.  This
+	 * will make the file the correct size.  Make sure the offset is
+	 * computed in 64 bits, and the function called can handle 64 bits.
+	 */
+	if (ftruncate64(out, (u64)total_blocks * sparse_header.blk_sz)) {
+		fprintf(stderr, "Error calling ftruncate() to set the image size\n");
+		exit(-1);
+	}
+
+	close(in);
+	close(out);
+
+	if (sparse_header.total_blks != total_blocks) {
+		fprintf(stderr, "Wrote %d blocks, expected to write %d blocks\n",
+			 total_blocks, sparse_header.total_blks);
+		exit(-1);
+	}
+
+	exit(0);
+}
+
diff --git a/uuid.c b/uuid.c
index 33d2494..fc257b6 100644
--- a/uuid.c
+++ b/uuid.c
@@ -16,12 +16,7 @@
 
 #include <string.h>
 
-#ifdef USE_MINGW
-#include <winsock2.h>
-#else
 #include <arpa/inet.h>
-#endif
-
 #include "ext4_utils.h"
 #include "sha1.h"
 #include "uuid.h"
