From f48598d5914ff5935c0ba9f1ea07552dc453df8a Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Wed, 25 May 2016 16:59:22 +0300
Subject: [PATCH 0468/2241] mvneta: Fix SWCC support

- dma_sync must be done after copy and before refill
- dma_unmap must be done on originally mapped address
(before add rx_offset_correction)
- Correct usage of rx_offset_correction and NETA_SKB_PAD

Change-Id: I4d78fa019c5ad5b6b156c67083dcd75db2fc08f0
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/30083
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 drivers/net/ethernet/marvell/mvneta.c | 45 +++++++++++++++++++----------------
 1 file changed, 25 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index 11bdc13..eac6b00 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -1643,7 +1643,7 @@ static void mvneta_rxq_drop_pkts(struct mvneta_port *pp,
 		 */
 		data = (u8 *)(pp->data_high | (u64)data);
 #endif
-		dma_unmap_single(pp->dev->dev.parent, rx_desc->buf_phys_addr,
+		dma_unmap_single(pp->dev->dev.parent, rx_desc->buf_phys_addr - pp->rx_offset_correction,
 				 MVNETA_RX_BUF_SIZE(pp->pkt_size), DMA_FROM_DEVICE);
 		mvneta_frag_free(pp, data);
 	}
@@ -1707,18 +1707,24 @@ err_drop_frame:
 		if (rx_bytes <= rx_copybreak) {
 			/* better copy a small frame and not unmap the DMA region */
 			skb = netdev_alloc_skb_ip_align(dev, rx_bytes);
-			if (unlikely(!skb))
+			if (unlikely(!skb)) {
+				netdev_warn(dev, "rxq #%d - Can't allocate skb. rx_bytes = %d bytes\n",
+					    rxq->id, rx_bytes);
 				goto err_drop_frame;
+			}
 
-			dma_sync_single_range_for_cpu(dev->dev.parent,
-			                              rx_desc->buf_phys_addr,
-			                              MVNETA_MH_SIZE + NET_SKB_PAD,
-			                              rx_bytes,
-			                              DMA_FROM_DEVICE);
-			memcpy(skb_put(skb, rx_bytes),
+			/* Copy data from buffer to SKB without Marvell header */
+			memcpy(skb->data,
 			       data + MVNETA_MH_SIZE + NET_SKB_PAD,
 			       rx_bytes);
 
+			skb_put(skb, rx_bytes);
+			dma_sync_single_range_for_cpu(dev->dev.parent,
+						      phys_addr,
+						      NET_SKB_PAD - pp->rx_offset_correction,
+						      rx_bytes + MVNETA_MH_SIZE,
+						      DMA_FROM_DEVICE);
+
 			skb->protocol = eth_type_trans(skb, dev);
 			mvneta_rx_csum(pp, rx_status, skb);
 			napi_gro_receive(napi, skb);
@@ -1730,24 +1736,23 @@ err_drop_frame:
 			continue;
 		}
 
-		/* Refill processing */
-		err = mvneta_rx_refill(pp, rx_desc);
-		if (err) {
-			netdev_err(dev, "Linux processing - Can't refill\n");
-			rxq->missed++;
+		skb = build_skb(data, pp->frag_size > PAGE_SIZE ? 0 : pp->frag_size);
+		if (unlikely(!skb)) {
+			netdev_warn(dev, "rxq #%d - Can't build skb. frag_size = %d bytes\n",
+				    rxq->id, pp->frag_size);
 			goto err_drop_frame;
 		}
 
-		skb = build_skb(data, pp->frag_size > PAGE_SIZE ? 0 : pp->frag_size);
-
-		/* After refill old buffer has to be unmapped regardless
-		 * the skb is successfully built or not.
-		 */
-		dma_unmap_single(dev->dev.parent, phys_addr,
+		dma_unmap_single(dev->dev.parent, phys_addr - pp->rx_offset_correction,
 				 MVNETA_RX_BUF_SIZE(pp->pkt_size), DMA_FROM_DEVICE);
 
-		if (!skb)
+		/* Refill processing */
+		err = mvneta_rx_refill(pp, rx_desc);
+		if (err) {
+			netdev_warn(dev, "rxq #%d - Can't allocate RX buffer. Refill stopped\n", rxq->id);
+			rxq->missed++;
 			goto err_drop_frame;
+		}
 
 		rcvd_pkts++;
 		rcvd_bytes += rx_bytes;
-- 
2.7.4

