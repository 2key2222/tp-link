From 234d86b40b8f4adeaac41510fb8a10c1cd2abdbd Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Wed, 17 Feb 2016 13:25:42 +0200
Subject: [PATCH 0105/2241] ap806: thermal: added support for ap806 thermal
 sensor

- extended the armada thermal driver to support ap806
- updated Kconfig description
- added device tree entries for ap806
- enabled driver in LSP defconfig

Change-Id: I7cfcb1f4a997247b73971e70e37cc94bc4891891
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
---
 .../devicetree/bindings/thermal/armada-thermal.txt |  1 +
 arch/arm64/boot/dts/marvell/armada-ap806.dtsi      |  6 ++
 arch/arm64/configs/mvebu_v8_lsp_defconfig          |  3 +-
 drivers/thermal/Kconfig                            |  4 +-
 drivers/thermal/armada_thermal.c                   | 86 +++++++++++++++++++++-
 5 files changed, 95 insertions(+), 5 deletions(-)

diff --git a/Documentation/devicetree/bindings/thermal/armada-thermal.txt b/Documentation/devicetree/bindings/thermal/armada-thermal.txt
index 4698e0e..b0048d5 100644
--- a/Documentation/devicetree/bindings/thermal/armada-thermal.txt
+++ b/Documentation/devicetree/bindings/thermal/armada-thermal.txt
@@ -7,6 +7,7 @@ Required properties:
 		marvell,armada375-thermal
 		marvell,armada380-thermal
 		marvell,armadaxp-thermal
+		marvell,armada-ap806-thermal
 
 - reg:		Device's register space.
 		Two entries are expected, see the examples below.
diff --git a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
index 96c4bf2..32af34f 100644
--- a/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-ap806.dtsi
@@ -225,6 +225,12 @@
 				msi-parent = <&gic_v2m0>;
 				dma-coherent;
 			};
+
+			thermal@7f008c {
+				compatible = "marvell,armada-ap806-thermal";
+				reg = <0x7f008C 0x4>, <0x7f0084 0x4>;
+				status = "okay";
+			};
 		};
 	};
 
diff --git a/arch/arm64/configs/mvebu_v8_lsp_defconfig b/arch/arm64/configs/mvebu_v8_lsp_defconfig
index 491f6ce..8a5f1b3 100644
--- a/arch/arm64/configs/mvebu_v8_lsp_defconfig
+++ b/arch/arm64/configs/mvebu_v8_lsp_defconfig
@@ -106,7 +106,6 @@ CONFIG_SERIAL_XILINX_PS_UART=y
 CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
 CONFIG_VIRTIO_CONSOLE=y
 # CONFIG_HW_RANDOM is not set
-CONFIG_I2C=y
 CONFIG_SPI=y
 CONFIG_SPI_PL022=y
 CONFIG_GPIOLIB=y
@@ -116,6 +115,8 @@ CONFIG_POWER_RESET_VEXPRESS=y
 CONFIG_POWER_RESET_XGENE=y
 CONFIG_POWER_RESET_SYSCON=y
 # CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_ARMADA_THERMAL=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
 CONFIG_FB=y
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index 8cc4ac6..936e759 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -247,12 +247,12 @@ config DB8500_THERMAL
 	  thermal zone if trip points reached.
 
 config ARMADA_THERMAL
-	tristate "Armada 370/XP thermal management"
+	tristate "Armada 370/XP/8K thermal management"
 	depends on ARCH_MVEBU || COMPILE_TEST
 	depends on OF
 	help
 	  Enable this option if you want to have support for thermal management
-	  controller present in Armada 370 and Armada XP SoC.
+	  controller present in Armada 370, Armada XP, and Armada 8K SoC.
 
 config TEGRA_SOCTHERM
 	tristate "Tegra SOCTHERM thermal management"
diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c
index ae75328..44bea5c 100644
--- a/drivers/thermal/armada_thermal.c
+++ b/drivers/thermal/armada_thermal.c
@@ -41,6 +41,15 @@
 #define A375_HW_RESETn			BIT(8)
 #define A380_HW_RESET			BIT(8)
 
+#define AP806_START	BIT(0)
+#define AP806_RESET	BIT(1)
+#define AP806_ENABLE	BIT(2)
+
+/* For AP806 TSEN output format is signed as a 2s complement number
+	ranging from-512 to +511*/
+#define AP806_TSEN_OUTPUT_MSB		512
+#define AP806_TSEN_OUTPUT_COMP		1024
+
 struct armada_thermal_data;
 
 /* Marvell EBU Thermal Sensor Dev Structure */
@@ -68,6 +77,8 @@ struct armada_thermal_data {
 	unsigned int temp_shift;
 	unsigned int temp_mask;
 	unsigned int is_valid_shift;
+
+	struct thermal_zone_device_ops *ops;
 };
 
 static void armadaxp_init_sensor(struct platform_device *pdev,
@@ -147,6 +158,18 @@ static void armada380_init_sensor(struct platform_device *pdev,
 	}
 }
 
+static void armada_ap806_init_sensor(struct platform_device *pdev,
+				  struct armada_thermal_priv *priv)
+{
+	unsigned long reg = readl_relaxed(priv->control);
+
+	reg &= ~AP806_RESET;
+	reg |= AP806_START;
+	reg |= AP806_ENABLE;
+	writel(reg, priv->control);
+	mdelay(10);
+}
+
 static bool armada_is_valid(struct armada_thermal_priv *priv)
 {
 	unsigned long reg = readl_relaxed(priv->sensor);
@@ -183,10 +206,47 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 	return 0;
 }
 
-static struct thermal_zone_device_ops ops = {
+static int armada_ap806_get_temp(struct thermal_zone_device *thermal, int *temp)
+{
+	struct armada_thermal_priv *priv = thermal->devdata;
+	unsigned long reg;
+	unsigned long m, b, div;
+
+	/* Valid check */
+	if (priv->data->is_valid && !priv->data->is_valid(priv)) {
+		dev_err(&thermal->device,
+			"Temperature sensor reading not valid\n");
+		return -EIO;
+	}
+
+	reg = readl_relaxed(priv->sensor);
+	reg = (reg >> priv->data->temp_shift) & priv->data->temp_mask;
+
+	/* TSEN output format is signed as a 2s complement number
+	    ranging from-512 to +511. when MSB is set, need to
+	    calculate the complement number */
+	if (reg >= AP806_TSEN_OUTPUT_MSB)
+		reg = reg - AP806_TSEN_OUTPUT_COMP;
+
+	/* Get formula coeficients */
+	b = priv->data->coef_b;
+	m = priv->data->coef_m;
+	div = priv->data->coef_div;
+
+	*temp = ((m * reg) + b) / div;
+
+	return 0;
+}
+
+static struct thermal_zone_device_ops armada_ops = {
 	.get_temp = armada_get_temp,
 };
 
+static struct thermal_zone_device_ops armada_ap806_ops = {
+	.get_temp = armada_ap806_get_temp,
+};
+
+
 static const struct armada_thermal_data armadaxp_data = {
 	.init_sensor = armadaxp_init_sensor,
 	.temp_shift = 10,
@@ -194,6 +254,7 @@ static const struct armada_thermal_data armadaxp_data = {
 	.coef_b = 3153000000UL,
 	.coef_m = 10000000UL,
 	.coef_div = 13825,
+	.ops = &armada_ops,
 };
 
 static const struct armada_thermal_data armada370_data = {
@@ -205,6 +266,7 @@ static const struct armada_thermal_data armada370_data = {
 	.coef_b = 3153000000UL,
 	.coef_m = 10000000UL,
 	.coef_div = 13825,
+	.ops = &armada_ops,
 };
 
 static const struct armada_thermal_data armada375_data = {
@@ -216,6 +278,7 @@ static const struct armada_thermal_data armada375_data = {
 	.coef_b = 3171900000UL,
 	.coef_m = 10000000UL,
 	.coef_div = 13616,
+	.ops = &armada_ops,
 };
 
 static const struct armada_thermal_data armada380_data = {
@@ -228,8 +291,23 @@ static const struct armada_thermal_data armada380_data = {
 	.coef_m = 2000096UL,
 	.coef_div = 4201,
 	.inverted = true,
+	.ops = &armada_ops,
+};
+
+static const struct armada_thermal_data armada_ap806_data = {
+	.is_valid = armada_is_valid,
+	.init_sensor = armada_ap806_init_sensor,
+	.is_valid_shift = 16,
+	.temp_shift = 0,
+	.temp_mask = 0x3ff,
+	.coef_b = 153400,
+	.coef_m = 425,
+	.coef_div = 1000,
+	.inverted = true,
+	.ops = &armada_ap806_ops,
 };
 
+
 static const struct of_device_id armada_thermal_id_table[] = {
 	{
 		.compatible = "marvell,armadaxp-thermal",
@@ -248,6 +326,10 @@ static const struct of_device_id armada_thermal_id_table[] = {
 		.data       = &armada380_data,
 	},
 	{
+		.compatible = "marvell,armada-ap806-thermal",
+		.data       = &armada_ap806_data,
+	},
+	{
 		/* sentinel */
 	},
 };
@@ -282,7 +364,7 @@ static int armada_thermal_probe(struct platform_device *pdev)
 	priv->data->init_sensor(pdev, priv);
 
 	thermal = thermal_zone_device_register("armada_thermal", 0, 0,
-					       priv, &ops, NULL, 0, 0);
+					       priv, priv->data->ops, NULL, 0, 0);
 	if (IS_ERR(thermal)) {
 		dev_err(&pdev->dev,
 			"Failed to register thermal zone device\n");
-- 
2.7.4

